<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>Datajure: Docs</title>
        

<meta name="description" content="BackgroundClojure is a functional programming language, a dialect of Lisp. It is excellent for concurrency operations with concise syntax and immutable data structures. It simplifies concurrency or multithreaded programming due to its immutable core data structures. The in-built macro system in the Lisp languages with the code-as-data philosophy also enables huge flexibility in programs.">

<meta property="og:description" content="BackgroundClojure is a functional programming language, a dialect of Lisp. It is excellent for concurrency operations with concise syntax and immutable data structures. It simplifies concurrency or multithreaded programming due to its immutable core data structures. The in-built macro system in the Lisp languages with the code-as-data philosophy also enables huge flexibility in programs.">

<meta property="og:url" content="https://clojure-finance.github.io/datajure-website/datajure-website/pages-output/docs/" />
<meta property="og:title" content="Docs" />
<meta property="og:type" content="article" />

        <meta content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" name="viewport">
        
        <link rel="shortcut icon" href="images/ico/favicon.png">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Titillium+Web:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Titillium+Web:wght@400;700&display=swap" rel="stylesheet">
        <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-EVSTQN3/azprG1Anm3QDgpJLIm9Nao0Yz1ztcQTwFspd3yD65VohhpuuCOmLASjC" crossorigin="anonymous">
        <link href="/datajure-website/css/normalize.css" rel="stylesheet" type="text/css" />
        <link href="/datajure-website/css/blog.css" rel="stylesheet" type="text/css" />
        <link href="/datajure-website/css/lotus-highlightjs.min.css" rel="stylesheet" type="text/css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css" integrity="sha512-z3gLpd7yknf1YoNbCzqRKc4qyor8gaKU1qmn+CShxbuBusANI9QpRohGBreCFkKxLhei6S9CQXFEbbKuqLg0DA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/default.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-MrcW6ZMFYlzcLA8Nl+NtUVF0sA7MsXsP1UyJoMp4YLEuNSfAP+JcXn/tWtIaxVXM" crossorigin="anonymous"></script>
    </head>
    <body>
        <aside id="sidebar">
            <div id="logo">
                <a title="Datajure" href="/datajure-website/">
                    <div class="title-text text desktop-and-tablet-only">
                        <i class="desktop-and-tablet-only fa fa-table"></i>
                        <br/><br/>
                        Datajure
                    </div>
                    <div class="title-text text mobile-only">Datajure</div>
                </a>
            </div> 

            <nav id="sidebar-links">
                <nav id="menucont">
                    <ul class="menu">
                        <li ><a title="Home" href="/datajure-website/"><div class="menu-item-text">Home</div></a></li>
                        
                        <li >
                            <a href="/datajure-website/pages-output/quick-start/"><div class="menu-item-text">Quick Start</div></a>
                        </li>
                        
                        <li  class="active" >
                            <a href="/datajure-website/pages-output/docs/"><div class="menu-item-text">Docs</div></a>
                        </li>
                        
                        <li >
                            <a href="/datajure-website/pages-output/examples/"><div class="menu-item-text">Examples</div></a>
                        </li>
                        
                        <li ><a title="Archives" href="/datajure-website/archives/"><div class="menu-item-text">Archives</div></a></li>
                    </ul>
                </nav>

                <nav id="socialmedia">
                    <ul>
                        <li><a target="_blank" title="RSS" href="/datajure-website/feed.xml" rel="external"><i class="icon fa-solid fa-rss"></i></a></li>
                        <li><a target="_blank" title="GitHub" href="https://github.com/clojure-finance/datajure" rel="external"><i class="icon fa-brands fa-github"></i></a></li>
                    </ul>
                </nav>
            </nav>
        </aside>

        <article id="main">
            
<div id="custom-page">
    <div id="page-header">
        <h1>Docs</h1>
    </div>
    <ul class="toc"><li><a href="#background">Background</a></li><ul><li><a href="#macro-system-in-clojure">Macro System in Clojure</a></li><li><a href="#domain-specific-language">Domain-specific Language</a></li></ul><li><a href="#overview">Overview</a></li><li><a href="#logical-processing-order">Logical Processing Order</a></li><li><a href="#syntax">Syntax</a></li><ul><li><a href="#row-selection-section">Row Selection Section</a></li><ul><li><a href="#row-selection-by-filter">Row Selection by Filter</a></li><li><a href="#row-selection-by-index">Row Selection by Index</a></li><li><a href="#row-selection-with-both-filter-and-row-index">Row Selection with Both Filter and Row Index</a></li></ul><li><a href="#column-selection-section">Column Selection Section</a></li><li><a href="#optional-section">Optional Section</a></li><ul><li><a href="#optional-operation">Optional Operation</a></li><li><a href="#group-by">Group by</a></li><li><a href="#sort-by">Sort by</a></li></ul><li><a href="#aggregate-function">Aggregate Function</a></li></ul><li><a href="#backends">Backends</a></li><ul><li><a href="#techmldataset"><code>tech.ml.dataset</code></a></li><li><a href="#tablecloth">Tablecloth</a></li><li><a href="#clojask">Clojask</a></li><li><a href="#geni">Geni</a></li></ul></ul>
    <h2 id="background">Background</h2><p>Clojure is a functional programming language, a dialect of Lisp. It is excellent for concurrency operations with concise syntax and immutable data structures. It simplifies concurrency or multithreaded programming due to its immutable core data structures. The in-built macro system in the Lisp languages with the code-as-data philosophy also enables huge flexibility in programs.</p><h3 id="macro-system-in-clojure">Macro System in Clojure</h3><p>The macro system in Clojure allows the compiler to be extended by code. The reader accepts the input code and constructs an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract Syntax Tree (AST)</a>, which will then be transformed by the macro expander into another AST for execution. The transformation using the macros could be defined by the user. Such a feature provides an excellent foundation for defining a syntax in Clojure, subject to its fundamental syntax.</p><p>The figure below shows the overview of the evaluation process of Clojure.</p><p><img src="../../img/clojure_evaluation.png" alt="Clojure Compilation Overview" /></p><h3 id="domain-specific-language">Domain-specific Language</h3><p><a href="https://en.wikipedia.org/wiki/Domain-specific_language">Domain-Specific Language (DSL)</a> is a computer language, declared syntax or grammar that is specialised in a specific application. In contrast to <a href="https://en.wikipedia.org/wiki/General-purpose_language">General-Purpose Language (GPL)</a>, the implementation of DSL is designed with specific goals in that application domain. The use of macros in Lisp dialects enables developers to rewrite source code at compile-time, making implementation of DSL more convenient. As one of the Lisp dialects, Clojure also inherits such an advantage. In addition to macros, the heavy use of core data literals in Clojure also gives an extensive developing opportunity in implementing DSLs.</p><h2 id="overview">Overview</h2><p><img src="../../img/methodology.png" alt="Overview of Methodology" /></p><p>Datajure takes the query code written in the custom syntax as input, phrasing it into a Clojure map containing the arguments of different operations. The library functions are called according to our logical processing order, returning the data table.</p><h2 id="logical-processing-order">Logical Processing Order</h2><p>Simply put, Datajure implemented the functionality of the <code>SELECT</code> statements in <a href="https://en.wikipedia.org/wiki/SQL">Structured Query Language (SQL)</a>, a declarative query language designed for managing the data in a <a href="https://en.wikipedia.org/wiki/Relational_database">Relational Database Management System (RDBMS)</a>, but with slightly different set of operations involved, due to the nature of our target usage scenario. Theerefore, the logical processing order of the <code>SELECT</code> statement has been adopted in Datajure.</p><p>The following table compares the supported operations and their logical processing order of Datajure and SQL <code>SELECT</code>.</p><table><thead><tr><th align="center">Datajure Order</th><th align="center">SQL Order</th><th align="center">Operations</th><th align="center">Description</th></tr></thead><tbody><tr><td align="center"></td><td align="center">1</td><td align="center"><code>FROM</code></td><td align="center">Specifies a table, view, table variable, or derived table source, with or without an alias, to use in the Transact-SQL statement</td></tr><tr><td align="center"></td><td align="center">2</td><td align="center"><code>ON</code></td><td align="center">Specifies arbitrary conditions or specify columns to join</td></tr><tr><td align="center"></td><td align="center">3</td><td align="center"><code>JOIN</code></td><td align="center">Retrieves data from two or more tables based on logical relationships between the tables</td></tr><tr><td align="center">1</td><td align="center">4</td><td align="center"><code>WHERE</code></td><td align="center">Specifies the search condition for the rows returned by the query</td></tr><tr><td align="center" colspan="2">2</td><td align="center"><code>ROW</code></td><td align="center">Specifies the row index for the rows returned by the query</td></tr><tr><td align="center">3</td><td align="center">5</td><td align="center"><code>GROUP BY</code></td><td align="center">Divides the query result into groups of rows</td></tr><tr><td align="center"></td><td align="center">6</td><td align="center"><code>WITH CUBE</code>/<code>WITH ROLLUP</code></td><td align="center">Extend functions for <code>GROUP BY</code></td></tr><tr><td align="center">4</td><td align="center">7</td><td align="center"><code>HAVING</code></td><td align="center">Specifies a search condition for a group or an aggregate</td></tr><tr><td align="center">5</td><td align="center">8</td><td align="center"><code>SELECT</code></td><td align="center">Specifies the columns to be returned by the query</td></tr><tr><td align="center"></td><td align="center">9</td><td align="center"><code>DISTINCT</code></td><td align="center">Specifies to return only distinct values</td></tr><tr><td align="center">6</td><td align="center">10</td><td align="center"><code>ORDER BY</code></td><td align="center">Sorts data returned by a query</td></tr><tr><td align="center"></td><td align="center">11</td><td align="center"><code>TOP</code></td><td align="center">Specifies the number of records to return</td></tr></tbody></table><h2 id="syntax">Syntax</h2><p>A query statement has three sections: row selection section, column selection section and optional section. Each section is represented by a sequence of operations enclosed within <code>[]</code>.</p><pre><code class="clojure">(dtj/query data [ROW-SELECTION-SECTION] [COLUMN-SELECTION-SECTION] [OPTIONS])
</code></pre><h3 id="row-selection-section">Row Selection Section</h3><p>The first section of the argument input is the row selection section. It corresponds to the <code>WHERE</code>, <code>HAVING</code> and <code>ROW</code> operations in the table for logical processing order. The user could either select the rows using filters or by row index. The use of a filter would override row index selection.</p><p>To select all rows, just leave the section empty instead.</p><h4 id="row-selection-by-filter">Row Selection by Filter</h4><pre><code class="clojure">[col filter-function]
</code></pre><p>This shows the syntax of row selection using a filter. <code>col</code> refers to the column to be filtered, and <code>filter-function</code> refers to the filtering function. This is one of the powerful features - the filtering function can be any custom function returning a boolean result. One can define a filtering function for the selection using Clojure built-in fast function syntax: <code>#{ ... }</code>. This is valid as long as it returns a boolean.</p><h4 id="row-selection-by-index">Row Selection by Index</h4><pre><code class="clojure">row-index
</code></pre><p>This shows the syntax of row selection using row index. <code>row-index</code> refers to the index of the desired row.</p><h4 id="row-selection-with-both-filter-and-row-index">Row Selection with Both Filter and Row Index</h4><pre><code class="clojure">[col filter-function] row-index
</code></pre><p>This shows the case where filtering overrides the use of row index. In this case, the filtering function would override the row index. The pipeline will ignore the row-index part.</p><h3 id="column-selection-section">Column Selection Section</h3><p>The second section of the argument input is the selection of columns.</p><pre><code class="clojure">col
</code></pre><p>This is the syntax of column selection, where <code>col</code> refers to the column selected.</p><p>To select all columns, just put an empty list <code>[]</code> instead.</p><h3 id="optional-section">Optional Section</h3><p>The third section of the argument section is the optional section. This section specifies all the optional operations, including the <code>GROUP BY</code> and <code>SORT BY</code> operations.</p><h4 id="optional-operation">Optional Operation</h4><pre><code class="clojure">operation-keyword operation-arguments
</code></pre><p>This shows the syntax of an optional operation. <code>operation-keyword</code> refers to the operation keyword for the program to identify the operation. It includes <code>:group-by</code> and <code>:sort-by</code>. <code>operation-arguments</code> refers to the corresponding operation arguments, subject to the operation.</p><h4 id="group-by">Group by</h4><pre><code class="clojure">:group-by col
</code></pre><p>This shows the syntax of a group by operation. <code>col</code> refers to the column(s) to be grouped.</p><h4 id="sort-by">Sort by</h4><pre><code class="clojure">:sort-by col sort-by-function
</code></pre><p>This shows the syntax of a sort by operation. <code>col</code> refers to the column to be sorted. <code>sort-by-function</code> refers to the sorting function, with <code>&lt;</code> (ascending order) as default. Similar to the filtering function, the sorting function can be any custom function returning a boolean result. It can also be Clojure operator like <code>&lt;</code> or <code>&gt;</code>, <code>clojure.core/compare</code> or custom <code>java.util.Comparator</code>.</p><h3 id="aggregate-function">Aggregate Function</h3><p>With the <code>group-by</code> operation is implemented, aggregate functions are also needed to be implemented in the syntax.</p><pre><code class="clojure">aggregate-keyword col
</code></pre><p>This shows the syntax of an aggregated column. <code>aggregate-keyword</code> specifies the aggregated function. col refers to the column to be aggregated. One could directly replace the aggregated column syntax in any column argument. Table below shows the complete aggregate functions available and the corresponding aggregate keywords.</p><table><thead><tr><th>Aggregate Function</th><th>Keyword</th></tr></thead><tbody><tr><td>Minimum</td><td><code>:min</code></td></tr><tr><td>Maximum</td><td><code>:max</code></td></tr><tr><td>Mode</td><td><code>:mode</code></td></tr><tr><td>Summation</td><td><code>:sum</code></td></tr><tr><td>Standard Deviation</td><td><code>:sd</code></td></tr><tr><td>Skew</td><td><code>:skew</code></td></tr><tr><td>NumberValid Rows</td><td><code>:n-valid</code></td></tr><tr><td>Number of Missing Rows</td><td><code>:n-missing</code></td></tr><tr><td>Total Number of Rows</td><td><code>:n</code></td></tr></tbody></table><h2 id="backends">Backends</h2><p>Currently, Datajure supports the following data processing libraries as the backend: <a href="https://github.com/techascent/tech.ml.dataset"><code>tech.ml.dataset</code></a>, <a href="https://github.com/scicloj/tablecloth">Tablecloth</a>, <a href="https://github.com/clojure-finance/clojask">Clojask</a> and <a href="https://github.com/zero-one-group/geni">Geni</a>.</p><p>Although Datajure uses Tablecloth by default, the users can still specify their preferred backend. The statement to specify the backend has the following syntax:</p><pre><code class="clojure">(dtj/set-backend BACKEND)
</code></pre><p>For example, we can write <code>(dtj/set-backend "tech.ml.dataset")</code> to specify <code>tech.ml.dataset</code> as the backend.</p><p>For technical details, please refer to our <a href="/datajure-website/archives/">posts</a>.</p><p>Although we strive for consistency in the behavior of each backend. However, due to the differences in the APIs they provide, there are still some operations that are not fully supported in some backends.</p><h3 id="techmldataset"><code>tech.ml.dataset</code></h3><p>All operations above are supported.</p><h3 id="tablecloth">Tablecloth</h3><p>All operations above are supported.</p><h3 id="clojask">Clojask</h3><p>All operations above are supported. However, due to the limitations of Clojask itself, the user must manually load the dataset from a <code>.csv</code> file and store the final result in a file.</p><p>Example:</p><pre><code class="clojure">(ck/dataframe "example.csv")
</code></pre><p>For more information, please refer to the <a href="https://clojure-finance.github.io/clojask-website/posts-output/API/">API Docs</a> of Clojask.</p><h3 id="geni">Geni</h3><p>All operations above are supported. However, due to the limitations of Geni itself, customized comparators are not supported in the <code>:sort-by</code> operation, and the <code>filter-function</code> field must be an expression written with Geni operators, e.g., <code>g/&lt;</code>, instead of Clojure operators such as <code>&lt;</code>.</p><p>Example:</p><pre><code class="clojure">(g/=== :name (g/lit "Alice"))
(g/&amp;&amp; (g/&gt; :age 20) (g/&lt; :salary 1000))
</code></pre><p>For more information, please refer to the <a href="https://github.com/zero-one-group/geni">Docs</a> of Geni.</p>

    
    <div id="prev-next">
    
    <a class="prev" href="/datajure-website/pages-output/quick-start/"><i class="fa-solid fa-circle-left"></i><div class="nav-text">Quick Start</div></a>
    
    
    <a class="next" href="/datajure-website/pages-output/examples/"><div class="nav-text"">Examples</div><i class="fa-solid fa-circle-right"></i></a>
    
</div>

    

</div>

            <br/>
            <div id="footercont">
                Copyright &copy; 2024 Datajure
                <br>Powered by <a href="http://cryogenweb.org">Cryogen</a>
            </div>
        </article>

        <script src="/datajure-website/js/highlight.pack.js" type="application/javascript"></script>
        <script>hljs.initHighlightingOnLoad();</script>
        <script src="/datajure-website/js.dropdown.js" type="application/javascript"></script> 
        

        
        
    </body>
</html>
